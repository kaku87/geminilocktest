<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BaseRepositoryProvider.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">optimistic-lock</a> &gt; <a href="index.source.html" class="el_package">com.example.optimisticlock.repository</a> &gt; <span class="el_source">BaseRepositoryProvider.java</span></div><h1>BaseRepositoryProvider.java</h1><pre class="source lang-java linenums">package com.example.optimisticlock.repository;

import com.example.optimisticlock.annotation.TableName;
import com.example.optimisticlock.entity.BaseEntity;
import javax.persistence.Id;
import org.apache.ibatis.builder.annotation.ProviderContext;
import org.apache.ibatis.jdbc.SQL;
import org.apache.ibatis.annotations.Param;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;


import org.apache.ibatis.builder.annotation.ProviderMethodResolver;

// MyBatisの@*Providerから呼び出される共通SQLビルダー。
public class BaseRepositoryProvider implements ProviderMethodResolver {

    /**
     * エンティティ全フィールドをINSERTするSQLを生成する。
     * @param entity 永続化対象のエンティティ
     * @return INSERT文
     */
    public String insert(BaseEntity entity) {
        Class&lt;?&gt; entityClass = entity.getClass();
        TableName tableNameAnnotation = entityClass.getAnnotation(TableName.class);
        if (tableNameAnnotation == null) {
            throw new RuntimeException(&quot;Entity class &quot; + entityClass.getName() + &quot; must be annotated with @TableName&quot;);
        }
        String tableName = tableNameAnnotation.value();

<span class="fc" id="L38">        return new SQL() {{</span>
<span class="fc" id="L39">            INSERT_INTO(tableName);</span>
<span class="fc bfc" id="L40" title="All 2 branches covered.">            for (Field field : getAllFields(entityClass)) {</span>
<span class="fc" id="L41">                VALUES(camelToSnake(field.getName()), &quot;#{&quot; + field.getName() + &quot;}&quot;);</span>
            }
        }}.toString();
    }

    /**
     * versionとタイムスタンプを更新しながら指定エンティティを更新するSQLを生成する。
     * @param entity 更新対象のエンティティ
     * @return UPDATE文
     */
    public String update(BaseEntity entity) {
        Class&lt;?&gt; entityClass = entity.getClass();
        TableName tableNameAnnotation = entityClass.getAnnotation(TableName.class);
        if (tableNameAnnotation == null) {
            throw new RuntimeException(&quot;Entity class &quot; + entityClass.getName() + &quot; must be annotated with @TableName&quot;);
        }
        String tableName = tableNameAnnotation.value();

        List&lt;Field&gt; idFields = findIdFields(entityClass);

<span class="fc" id="L61">        return new SQL() {{</span>
<span class="fc" id="L62">            UPDATE(tableName);</span>

<span class="fc" id="L64">            String setClauses = Arrays.stream(getAllFields(entityClass))</span>
<span class="fc bfc" id="L65" title="All 6 branches covered.">                .filter(field -&gt; !field.isAnnotationPresent(Id.class) &amp;&amp; !field.getName().equals(&quot;zzcmnFdate&quot;) &amp;&amp; !field.getName().equals(&quot;version&quot;))</span>
<span class="fc" id="L66">                .map(field -&gt; camelToSnake(field.getName()) + &quot; = #{&quot; + field.getName() + &quot;}&quot;)</span>
<span class="fc" id="L67">                .collect(Collectors.joining(&quot;, &quot;));</span>

<span class="fc" id="L69">            SET(setClauses);</span>
<span class="fc" id="L70">            SET(&quot;version = version + 1&quot;);</span>
<span class="fc" id="L71">            SET(&quot;zzcmn_fdate = NOW()&quot;);</span>

<span class="fc bfc" id="L73" title="All 2 branches covered.">            for (Field idField : idFields) {</span>
<span class="fc" id="L74">                String idColumnName = camelToSnake(idField.getName());</span>
<span class="fc" id="L75">                String idFieldName = idField.getName();</span>
<span class="fc" id="L76">                WHERE(idColumnName + &quot; = #{&quot; + idFieldName + &quot;}&quot;);</span>
            }

<span class="fc" id="L79">            WHERE(&quot;version = #{version}&quot;);</span>
        }}.toString();
    }

    /**
     * 主キーとversionに基づいてレコードを削除するSQLを生成する。
     * @param entity 削除対象のエンティティ
     * @return DELETE文
     */
    public String delete(BaseEntity entity) {
        Class&lt;?&gt; entityClass = entity.getClass();
        TableName tableNameAnnotation = entityClass.getAnnotation(TableName.class);
        if (tableNameAnnotation == null) {
            throw new RuntimeException(&quot;Entity class &quot; + entityClass.getName() + &quot; must be annotated with @TableName&quot;);
        }
        String tableName = tableNameAnnotation.value();

        List&lt;Field&gt; idFields = findIdFields(entityClass);

<span class="fc" id="L98">        return new SQL() {{</span>
<span class="fc" id="L99">            DELETE_FROM(tableName);</span>

<span class="fc bfc" id="L101" title="All 2 branches covered.">            for (Field idField : idFields) {</span>
<span class="fc" id="L102">                String idColumnName = camelToSnake(idField.getName());</span>
<span class="fc" id="L103">                String idFieldName = idField.getName();</span>
<span class="fc" id="L104">                WHERE(idColumnName + &quot; = #{&quot; + idFieldName + &quot;}&quot;);</span>
            }

<span class="fc" id="L107">            WHERE(&quot;version = #{version}&quot;);</span>
        }}.toString();
    }

    /**
     * 主キー条件で単一レコードを検索するSQLを生成する。
     * @param entity 検索条件を保持するエンティティ
     * @return SELECT文
     */
    public String findById(BaseEntity entity) {
        Class&lt;?&gt; entityClass = entity.getClass();
        TableName tableNameAnnotation = entityClass.getAnnotation(TableName.class);
        if (tableNameAnnotation == null) {
            throw new RuntimeException(&quot;Entity class &quot; + entityClass.getName() + &quot; must be annotated with @TableName&quot;);
        }
        String tableName = tableNameAnnotation.value();

        SQL sql = new SQL().SELECT(&quot;*&quot;).FROM(tableName);
        List&lt;Field&gt; idFields = findIdFields(entityClass);
        for (Field idField : idFields) {
            sql.WHERE(camelToSnake(idField.getName()) + &quot; = #{&quot; + idField.getName() + &quot;}&quot;);
        }
        return sql.toString();
    }

    /**
     * マッパー型情報からエンティティクラスを特定し、全件取得のSQLを作成する。
     * @param context MyBatisが提供するプロバイダーコンテキスト
     * @return SELECT文
     */
    public String findAll(ProviderContext context) {
        Class&lt;?&gt; entityClass = getEntityClass(context);
        TableName tableNameAnnotation = entityClass.getAnnotation(TableName.class);
        if (tableNameAnnotation == null) {
            throw new RuntimeException(&quot;Entity class &quot; + entityClass.getName() + &quot; must be annotated with @TableName&quot;);
        }
        String tableName = tableNameAnnotation.value();

<span class="fc" id="L145">        return new SQL() {{</span>
<span class="fc" id="L146">            SELECT(&quot;*&quot;);</span>
<span class="fc" id="L147">            FROM(tableName);</span>
        }}.toString();
    }


    /**
     * 継承階層も含めて@Idが付与されたフィールドを収集する。
     * @param clazz 解析対象のクラス
     * @return @Idフィールドのリスト
     */
    private List&lt;Field&gt; findIdFields(Class&lt;?&gt; clazz) {
        List&lt;Field&gt; idFields = new ArrayList&lt;&gt;();
        for (Field field : getAllFields(clazz)) {
            if (field.isAnnotationPresent(Id.class)) {
                idFields.add(field);
            }
        }
        if (idFields.isEmpty()) {
            throw new RuntimeException(&quot;No @Id annotation found in class &quot; + clazz.getName() + &quot; or its superclasses.&quot;);
        }
        return idFields;
    }

    /**
     * 指定クラスとスーパークラスから全フィールドリストを取得する。
     * @param clazz 解析対象のクラス
     * @return フィールド配列
     */
    private Field[] getAllFields(Class&lt;?&gt; clazz) {
        List&lt;Field&gt; fields = new ArrayList&lt;&gt;();
        while (clazz != null) {
            Arrays.stream(clazz.getDeclaredFields())
                .filter(field -&gt; !Modifier.isStatic(field.getModifiers()))
                .filter(field -&gt; !field.isSynthetic())
                .filter(field -&gt; !field.getName().startsWith(&quot;$jacoco&quot;))
                .forEach(fields::add);
            clazz = clazz.getSuperclass();
        }
        return fields.toArray(new Field[0]);
    }

    /**
     * camelCaseのプロパティ名をスネークケースのカラム名へ変換する。
     * @param str プロパティ名
     * @return スネークケースへ変換した文字列
     */
    private static String camelToSnake(String str) {
        if (str == null) {
            return null;
        }
        return str.replaceAll(&quot;([a-z])([A-Z]+)&quot;, &quot;$1_$2&quot;).toLowerCase();
    }

    /**
     * 単一エンティティの楽観ロックチェック用SELECTを生成する。
     * @param entity 楽観ロック検証対象のエンティティ
     * @return SELECT文
     */
    public String checkUpdate(BaseEntity entity) {
        Class&lt;?&gt; entityClass = entity.getClass();
        TableName tableNameAnnotation = entityClass.getAnnotation(TableName.class);
        if (tableNameAnnotation == null) {
            throw new RuntimeException(&quot;Entity class &quot; + entityClass.getName() + &quot; must be annotated with @TableName&quot;);
        }
        String tableName = tableNameAnnotation.value();

        List&lt;Field&gt; idFields = findIdFields(entityClass);

<span class="fc" id="L215">        return new SQL() {{</span>
<span class="fc" id="L216">            SELECT(&quot;count(1)&quot;);</span>
<span class="fc" id="L217">            FROM(tableName);</span>

<span class="fc bfc" id="L219" title="All 2 branches covered.">            for (Field idField : idFields) {</span>
<span class="fc" id="L220">                String idColumnName = camelToSnake(idField.getName());</span>
<span class="fc" id="L221">                String idFieldName = idField.getName();</span>
<span class="fc" id="L222">                WHERE(idColumnName + &quot; = #{&quot; + idFieldName + &quot;}&quot;);</span>
            }

<span class="fc" id="L225">            WHERE(&quot;version = #{version}&quot;);</span>
        }}.toString();
    }

    /**
     * 複数エンティティのversionをまとめて確認するためのSELECTを生成する。
     * @param entities 楽観ロック検証対象エンティティのリスト
     * @return SELECT文
     */
    public String checkUpdateList(List&lt;BaseEntity&gt; entities) {
        if (entities == null || entities.isEmpty()) {
            return &quot;SELECT 0&quot;;
        }

        BaseEntity entity = entities.get(0);
        Class&lt;?&gt; entityClass = entity.getClass();
        TableName tableNameAnnotation = entityClass.getAnnotation(TableName.class);
        if (tableNameAnnotation == null) {
            throw new RuntimeException(&quot;Entity class &quot; + entityClass.getName() + &quot; must be annotated with @TableName&quot;);
        }
        String tableName = tableNameAnnotation.value();

        List&lt;Field&gt; idFields = findIdFields(entityClass);

        StringBuilder sql = new StringBuilder();
        sql.append(&quot;SELECT COUNT(1) FROM &quot;).append(tableName).append(&quot; WHERE &quot;);

        StringBuilder whereClause = new StringBuilder();
        whereClause.append(&quot;(&quot;);

        for (int i = 0; i &lt; entities.size(); i++) {
            if (i &gt; 0) {
                whereClause.append(&quot; OR &quot;);
            }
            whereClause.append(&quot;(&quot;);
            List&lt;String&gt; conditions = new ArrayList&lt;&gt;();
            for (Field idField : idFields) {
                conditions.add(camelToSnake(idField.getName()) + &quot; = #{list[&quot; + i + &quot;].&quot; + idField.getName() + &quot;}&quot;);
            }
            conditions.add(&quot;version = #{list[&quot; + i + &quot;].version}&quot;);
            whereClause.append(String.join(&quot; AND &quot;, conditions));
            whereClause.append(&quot;)&quot;);
        }
        whereClause.append(&quot;)&quot;);

        sql.append(whereClause);

        return sql.toString();
    }

    /**
     * BaseRepository&lt;T&gt;の型引数として宣言されたエンティティ型を取得する。
     * @param context MyBatisが提供するプロバイダーコンテキスト
     * @return エンティティクラス
     */
    private Class&lt;?&gt; getEntityClass(ProviderContext context) {
        // Every repository is expected to implement BaseRepository&lt;T&gt;; walk the type hierarchy until we find that T.
        for (Class&lt;?&gt; type = context.getMapperType(); type != null; type = type.getSuperclass()) {
            for (Type genericInterface : type.getGenericInterfaces()) {
                Class&lt;?&gt; entityClass = resolveEntityClass(genericInterface);
                if (entityClass != null) {
                    return entityClass;
                }
            }
        }
        throw new RuntimeException(&quot;Could not determine entity class for &quot; + context.getMapperType().getName());
    }

    /**
     * BaseRepository&lt;T&gt;型からエンティティクラスを抽出する補助メソッド。
     * @param candidate 解析対象の型情報
     * @return 抽出されたエンティティクラス、存在しない場合はnull
     */
    private Class&lt;?&gt; resolveEntityClass(Type candidate) {
        if (candidate instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) candidate;
            if (BaseRepository.class.equals(parameterizedType.getRawType())) {
                Type actualType = parameterizedType.getActualTypeArguments()[0];
                if (actualType instanceof Class) {
                    return (Class&lt;?&gt;) actualType;
                }
            }
        }
        return null;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>